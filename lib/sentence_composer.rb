DICTIONARY = { nouns: ['abcd', 'c', 'def', 'h', 'ij', 'cde'],
               verbs: ['bc', 'fg', 'g', 'hij', 'bcd'],
               articles: ['a', 'ac', 'e']
              }

def valid_word?(str)
  DICTIONARY[:verbs].include?(str) || DICTIONARY[:nouns].include?(str) || DICTIONARY[:articles].include?(str)
end

# Will return the String if valid sentence, otherwise an empty array
def sentence_validator(sentence)
  # a sentence MUST include a verb
  verb_count = 0
  # a sentence MUST include a noun OR...
  noun_count = 0
  # at least 2 articles if zero nouns
  article_count = 0
  # are there any invalid words that aren't part of the dictionary?
  invalid_count = 0

  sentence.split(' ').each do |word|
    if DICTIONARY[:verbs].include?(word)
      verb_count += 1
    elsif DICTIONARY[:nouns].include?(word)
      noun_count += 1
    elsif DICTIONARY[:articles].include?(word)
      article_count += 1
    else
      invalid_count += 1
    end
  end

  if invalid_count.zero? && (verb_count > 0) && (noun_count > 0 || article_count > 1)
    return sentence
  else
    return []
  end
end

def sentence_composer(input_str)
  return [] if input_str.is_a?(String) == false || input_str.empty?
  # consider using copy so that input may be down-cased....
  copy = ""
  copy += input_str.downcase
  count = 0
  result = []

  # an array to park finished sentences
  final_check = []

  # used to compare against the contents of final_check
  holding_tank = []

  # used to hold what's generated by the sentence_constructor method
  in_progress = []

  # used to add letters to the in_progress array (lines 83-89)
  hopper = []

  while count < input_str.length
    sentence_constructor_result = sentence_constructor(copy[count..-1])
    if sentence_constructor_result != false
      in_progress += sentence_constructor_result
      if in_progress != holding_tank
        if !holding_tank.empty? && !final_check.include?(holding_tank.join(' '))
          final_check << holding_tank.join(' ')
          holding_tank = []
          in_progress.each{|word| holding_tank << word}
        else
          # if holding_tank is empty, proceed to fill it...
          in_progress.each{|word| holding_tank << word}
        end
      end
      in_progress = []
      in_progress = copy.chars[0..count].each{ |item| in_progress << item }
      if valid_word?(in_progress[count]) == false
        # handle in_progress if an item inside isn't a valid_word
        if in_progress.size > 1 && !in_progress[1..(count - 1)].all?{|item| valid_word?(item)} # != true
          # escape out of the loop
          if !holding_tank.empty?
            final_check << holding_tank.join(' ')
            count += (copy.length - count)
          end
        else
          hopper += copy[(count + 1)..(count + 3)].chars
          until valid_word?(in_progress[count]) == true
            in_progress[count] += hopper.shift
              if hopper.empty?
                break
              end
          end
          count += (in_progress[count].length)
          if !in_progress.all?{|item| valid_word?(item)}# != true
            # escape out of the loop
            count += copy.length
          end
        end
      else
        count += 1
      end
    else
      # sentence_constructor returned false, time to exit the while loop
      count += copy.length
    end
  end
  if final_check.empty? && !holding_tank.empty?
    final_check << holding_tank.join(' ')
  end
  # final steps to return a result to the user...
  final_check = final_check.map{|sentence| sentence_validator(sentence)}
  result << final_check.keep_if{|item| !item.empty?}
  result.flatten
end

def sentence_constructor(str)
  potential_sentence_array = []

  while !str.empty?
    if str.length > 3 && valid_word?(str[0..3]) == true
      potential_sentence_array << str.slice!(0..3)
    elsif str.length > 2 && valid_word?(str[0..2]) == true
      potential_sentence_array << str.slice!(0..2)
    elsif str.length > 1 && valid_word?(str[0..1]) == true
      potential_sentence_array << str.slice!(0..1)
    elsif valid_word?(str[0]) == true
      potential_sentence_array << str.slice!(0)
    else
      return false # because the next letter isn't part of the DICTIONARY
    end
  end
  return potential_sentence_array
end



# test_str = 'abcdefg' #-> ["a bc def g", "a bcd e fg", "abcd e fg"]

# test_str = "abcd" #-> []

# test_str = []

# test_str = "abcc" #-> ["a bc c"]

# test_str = 'abcdefgacde' #-> []

# test_str = 'abcdefgacdef'
# -> ["abcd e fg ac def", "a bcd e fg ac def", "a bc def g ac def"]

# test_str = 'bcdac' #-> [] why? It only has 1 verb, and 1 article.

# test_str = 'efgac' #-> ['e fg ac'] 1 verb and 2 articles.

# test_str = 'ecdefghabcd' #-> ['e cde fg h abcd', 'e c def g h abcd']

# sentence_composer(test_str)
